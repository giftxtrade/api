// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: event.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO "event" (
    "name",
    "description",
    "budget",
    "invitation_message",
    "draw_at",
    "close_at"
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, name, description, budget, invitation_message, draw_at, close_at, created_at, updated_at
`

type CreateEventParams struct {
	Name              string         `db:"name" json:"name"`
	Description       sql.NullString `db:"description" json:"description"`
	Budget            string         `db:"budget" json:"budget"`
	InvitationMessage string         `db:"invitation_message" json:"invitationMessage"`
	DrawAt            time.Time      `db:"draw_at" json:"drawAt"`
	CloseAt           time.Time      `db:"close_at" json:"closeAt"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.queryRow(ctx, q.createEventStmt, createEvent,
		arg.Name,
		arg.Description,
		arg.Budget,
		arg.InvitationMessage,
		arg.DrawAt,
		arg.CloseAt,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Budget,
		&i.InvitationMessage,
		&i.DrawAt,
		&i.CloseAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findAllEventsWithUser = `-- name: FindAllEventsWithUser :many
SELECT
    event.id, event.name, event.description, event.budget, event.invitation_message, event.draw_at, event.close_at, event.created_at, event.updated_at,
    p.participant, p.participant, p.participant, p.participant, p.participant, p.participant, p.participant, p.participant, p.participant, p.participant, p.participant, p.participant, p.participant, p.participant AS "participant"
FROM "event"
JOIN "participant" "p1" ON "p1"."event_id" = "event"."id"
JOIN "participant_user" "p" ON "p"."event_id" = "event"."id"
WHERE 
    "p1"."user_id" = $1
ORDER BY
    "event"."draw_at" DESC,
    "event"."close_at" DESC
`

type FindAllEventsWithUserRow struct {
	Event           Event           `db:"event" json:"event"`
	ParticipantUser ParticipantUser `db:"participant_user" json:"participantUser"`
}

func (q *Queries) FindAllEventsWithUser(ctx context.Context, userID sql.NullInt64) ([]FindAllEventsWithUserRow, error) {
	rows, err := q.query(ctx, q.findAllEventsWithUserStmt, findAllEventsWithUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAllEventsWithUserRow
	for rows.Next() {
		var i FindAllEventsWithUserRow
		if err := rows.Scan(
			&i.Event.ID,
			&i.Event.Name,
			&i.Event.Description,
			&i.Event.Budget,
			&i.Event.InvitationMessage,
			&i.Event.DrawAt,
			&i.Event.CloseAt,
			&i.Event.CreatedAt,
			&i.Event.UpdatedAt,
			&i.ParticipantUser.ID,
			&i.ParticipantUser.Name,
			&i.ParticipantUser.Email,
			&i.ParticipantUser.Address,
			&i.ParticipantUser.Organizer,
			&i.ParticipantUser.Participates,
			&i.ParticipantUser.Accepted,
			&i.ParticipantUser.EventID,
			&i.ParticipantUser.UserID,
			&i.ParticipantUser.CreatedAt,
			&i.ParticipantUser.UpdatedAt,
			&i.ParticipantUser.UserName,
			&i.ParticipantUser.UserEmail,
			&i.ParticipantUser.UserImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findEventForUser = `-- name: FindEventForUser :one
SELECT "event"."id"
FROM "event"
JOIN "participant" ON "participant"."event_id" = "event"."id"
JOIN "user" ON "user"."id" = "participant"."user_id"
WHERE
    "event"."id" = $1
        AND
    "user"."id" = $2
`

type FindEventForUserParams struct {
	EventID int64 `db:"event_id" json:"eventId"`
	UserID  int64 `db:"user_id" json:"userId"`
}

func (q *Queries) FindEventForUser(ctx context.Context, arg FindEventForUserParams) (int64, error) {
	row := q.queryRow(ctx, q.findEventForUserStmt, findEventForUser, arg.EventID, arg.UserID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const findEventForUserAsOrganizer = `-- name: FindEventForUserAsOrganizer :one
SELECT "event"."id"
FROM "event"
JOIN "participant" ON "participant"."event_id" = "event"."id"
JOIN "user" ON "user"."id" = "participant"."user_id"
WHERE
    "event"."id" = $1
        AND
    "participant"."organizer" = TRUE
        AND
    "user"."id" = $2
`

type FindEventForUserAsOrganizerParams struct {
	ID   int64 `db:"id" json:"id"`
	ID_2 int64 `db:"id_2" json:"id2"`
}

func (q *Queries) FindEventForUserAsOrganizer(ctx context.Context, arg FindEventForUserAsOrganizerParams) (int64, error) {
	row := q.queryRow(ctx, q.findEventForUserAsOrganizerStmt, findEventForUserAsOrganizer, arg.ID, arg.ID_2)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const findEventForUserAsParticipant = `-- name: FindEventForUserAsParticipant :one
SELECT "event"."id"
FROM "event"
JOIN "participant" ON "participant"."event_id" = "event"."id"
JOIN "user" ON "user"."id" = "participant"."user_id"
WHERE
    "event"."id" = $1
        AND
    "participant"."participates" = TRUE
        AND
    "user"."id" = $2
`

type FindEventForUserAsParticipantParams struct {
	ID   int64 `db:"id" json:"id"`
	ID_2 int64 `db:"id_2" json:"id2"`
}

func (q *Queries) FindEventForUserAsParticipant(ctx context.Context, arg FindEventForUserAsParticipantParams) (int64, error) {
	row := q.queryRow(ctx, q.findEventForUserAsParticipantStmt, findEventForUserAsParticipant, arg.ID, arg.ID_2)
	var id int64
	err := row.Scan(&id)
	return id, err
}
